---
title: "2019-08-representation"
author: "SRF Data, Felix Michel (felix.michel@srf.ch)"
date: "August 2019"
output:
  html_document:
    code_folding: show
    echo: TRUE
    warning: FALSE
    message: FALSE
    theme: simplex
    df_print: kable
    toc: yes
    toc_depth: 4
    toc_float: 
      collapsed: false
      smooth_scroll: false
subtitle: Vorprozessierung und Analyse
---


```{r, echo=FALSE}
# CONFIG
user_name <- "srfdata" # github user name
project_name <- "rddj-template" # adapt to new repo name
package_date <- "2018-09-01" # date of the CRAN snapshot that
# the checkpoint package uses
R_version <- "3.5.3" # R-Version to use
options(Ncpus = 4) # use 4 cores for parallelized installation of packages
if (R_version != paste0(version$major, ".", version$minor)){
  stop("ERROR: specified R version does not match currently used.")
}
```

## Vorbemerkungen

Dieses Dokument beschreibt die Vorprozessierung und explorative Analyse des Datensatzes, der Grundlage des auf srf.ch veröffentlichten Artikels [Wie gesund ist die Schweiz](http://www.srf.ch/data) ist.

SRF Data legt Wert darauf, dass die Datenvorprozessierung und -Analyse nachvollzogen und überprüft werden kann. SRF Data glaubt an das Prinzip offener Daten, aber auch offener und nachvollziehbarer Methoden. Zum anderen soll es Dritten ermöglicht werden, auf dieser Vorarbeit aufzubauen und damit weitere Auswertungen oder Applikationen zu generieren.

Das Endprodukt des vorliegenden Scripts, neben der explorativen Analyse, sind (Datenbeschreibung siehe unten):

* `councillors.json`: Datensatz aller Parlamentarier mit Geschlecht, Altersgruppe, Stadt-Land-Kategorisierung, Zivilstand, Bildung und Religionszugehörigkeit als JSON
* `representation.json`: Datensatz mit Ist- und Soll-Werten für die untersuchten Kategorien (Geschlecht, Altersgruppe etc.) als JSON


### R-Script & Daten

Die Vorprozessierung und Analyse wurde im Statistikprogramm R vorgenommen. Das zugrunde liegende Script sowie die prozessierten Daten können unter [diesem Link](https://srfdata.github.io/`r project_name`/rscript.zip) heruntergeladen werden. Durch Ausführen von `main.Rmd` kann der hier beschriebene Prozess nachvollzogen und der für den Artikel verwendete Datensatz generiert werden. Dabei werden Daten aus dem Ordner `input` eingelesen und Ergebnisse in den Ordner `output` geschrieben. 

SRF Data verwendet das [rddj-template](https://github.com/grssnbchr/rddj-template) von Timo Grossenbacher als Grundlage für seine R-Scripts. Entstehen bei der Ausführung dieses Scripts Probleme, kann es helfen, die Anleitung von [rddj-template](https://github.com/grssnbchr/rddj-template) zu studieren.

Debug-Informationen: *This report was generated on `r Sys.time()`. R version: `r paste0(version$major, ".", version$minor)` on `r version$platform`. For this report, CRAN packages as of `r package_date` were used.*

### GitHub

Der Code für die vorliegende Datenprozessierung ist auf [https://github.com/srfdata/`r project_name`](https://github.com/srfdata/`r project_name`) zur freien Verwendung verfügbar. 

### Lizenz

<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Lizenzvertrag" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Dataset" property="dct:title" rel="dct:type">`r project_name`</span> von <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/srfdata/`r project_name`" property="cc:attributionName" rel="cc:attributionURL">SRF Data</a> ist lizenziert unter einer <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International Lizenz</a>.

### Weitere Projekte

Code & Daten von [SRF Data](http://srf.ch/data) sind unter [http://srfdata.github.io](http://srfdata.github.io) verfügbar.

### Haftungsausschluss

Die veröffentlichten Informationen sind sorgfältig zusammengestellt, erheben aber keinen Anspruch auf Aktualität, Vollständigkeit oder Richtigkeit. Es wird keine Haftung übernommen für Schäden, die  durch die Verwendung dieses Scripts oder der daraus gezogenen Informationen entstehen. Dies gilt ebenfalls für Inhalte Dritter, die über dieses Angebot zugänglich sind.

### Datenbeschreibung 

#### `councillors_supplemented.csv`

| Attribut | Typ | Beschreibung |
|-------|------|-----------------------------------------------------------------------------|
| id | Numeric | Offizielle Id der Parlamentarischen Dienste |
| fistName | String | Vorname der Parlamentarier |
| lastName | String | Nachname der Parlamentarier |
| ageGroup | String | Altersgruppe der Parlamentarier (sieben Kategorien) |
| gender | String | Geschlecht der Parlamentarier (m, f) |
| urbanRural | String | Stadt-Land-Einteilung der Parlamentarier gemäss Raumgliederung des BfS, vier Kategorien (big_city, urban, periurban, rural) |
| maritalStatus | String | Zivilstand der Parlamentarier |
| education | String | Höchste Ausbildung der Parlamentarier |
| religion | String | Religionszugehörigkeit der Parlamentarier |
| party | String | Partei der Parlamentarier |


#### `representation.csv`

| Attribut | Typ | Beschreibung |
|-------|------|-----------------------------------------------------------------------------|
| category | String | Kategoriebezeichnung in Englisch für die jeweilige demografische Angabe |
| group | String | Unterschiedliche Einteilungen der jeweiligen Kategorie (Geschlecht, Altersgruppen etc.) |
| is | Numeric | Ist-Wert für eine Gruppe: So viele Parlamentarier unter 30 Jahren sitzen im Parlament |
| should | Numeric | Soll-Wert für eine Gruppe: So viel Parlamentarier unter 30 Jahren müssten im Vergleich zur ständigen Wohnbevölkerung über 15 Jahren im Parlament sitzen |


### Originalquelle

#### Schweizer Parlamentarier (National- und Ständerat), Stand 28. Mai 2019 

&rarr; `input/councillorsCouncillor-export_de_ergaenzt_mit_religion.csv`

Die Daten über die Parlamentarier stammen von den [Parlamentarischen Diensten](https://www.parlament.ch/de/%C3%BCber-das-parlament/parlamentsdienste) und wurden von [Smartvote](https://www.smartvote.ch/) durch die eigene Datenbank und weitere Recherchen ergänzt. Im Datensatz befinden sich neben den verwendeten Kategorien auch noch weitere Angaben (Beruf, Sprache etc.) enthalten.

#### Ergänzung zu den Daten der Parlamentarier

&rarr; `input/Missing Data Parlamentarians - Sheet1.csv`

Ergänzung des obigen Datensatzes durch eigene Recherche. 99 Parlamentarier wurden per Mail (Code für den automatisierten Mailversand weiter unten) angefragt, fehlende Daten zu ergänzen. Davon haben 64 Parlamentarier geantwortet.

#### Ständige Wohnbevölkerung nach Alter

&rarr; `input/je-d-01.02.03.02.xlsx`

Die Daten zur ständigen Wohnbevölkerung nach Alter haben wir von der [Webseite](https://www.bfs.admin.ch/bfs/de/home/statistiken/bevoelkerung/stand-entwicklung/alter-zivilstand-staatsangehoerigkeit.assetdetail.5866882.html) des Bundesamts für Statistik (BfS) heruntergeladen.

#### Ständige Wohnbevölkerung nach Religionszugehörigkeit

&rarr; `input/je-d-01.08.02.01.xlsx`

Die Daten zur ständigen Wohnbevölkerung ab 15 Jahren nach Religionszugehörigkeit haben wir von der [Webseite](https://www.bfs.admin.ch/bfs/de/home/statistiken/bevoelkerung/sprachen-religionen/religionen.assetdetail.7226715.html) des BfS heruntergeladen.

#### Ständige Wohnbevölkerung nach Zivilstand

&rarr; `input/su-d-01.02.03.03.xlsx`

Die Daten zur ständigen Wohnbevölkerung nach Zivilstand haben wir von der [Webseite](https://www.bfs.admin.ch/bfs/de/home/statistiken/kataloge-datenbanken/tabellen.assetdetail.5886132.html) des BfS heruntergeladen.

#### Ständige Wohnbevölkerung nach Bildung

&rarr; `input/su-d-40.02.15.08.01-2017.xlsx`

Die Daten zur ständigen Wohnbevölkerung ab 15 Jahren nach Bildung haben wir von der [Webseite](https://www.bfs.admin.ch/bfs/de/home/statistiken/kataloge-datenbanken/tabellen.assetdetail.7226522.html) des BfS heruntergeladen.

####  Ständige Wohnbevölkerung nach Alter und Gemeinde (Stand 31.12.2017)

&rarr; `input/su-d-01.02.03.06.xlsx`

Die Daten zur ständigen Wohnbevölkerung nach Alter und Gemeinde haben wir von der [Webseite](https://www.bfs.admin.ch/bfs/de/home/statistiken/kataloge-datenbanken/tabellen.assetdetail.5886142.html) des BfS heruntergeladen.

####  Raumgliederung

&rarr; `input/Raumgliederungen.xlsx`

Die Einteilung der Wohnorte der Parlamentarier in urban, periurban und rural haben wir der Raumgliederung des BfS entnommen (Gemeindetypologie 2012, 25 Typen, 9 Kategorien und Stadt/Land-Typologie). Die Tabelle haben wir aus der [Applikation der Schweizer Gemeinden](https://www.agvchapp.bfs.admin.ch/de/typologies/query) des BfS exportiert. Wir haben den offiziellen Gemeindestand vom 02.04.2017 verwendet mit 2240 Einträgen.


## Vorbereitungen

```{r, echo=FALSE}
detach_all_packages <- function() {
  basic_packages_blank <-  c("stats",
                             "graphics",
                             "grDevices",
                             "utils",
                             "datasets",
                             "methods",
                             "base")
  basic_packages <- paste("package:", basic_packages_blank, sep = "")

  package_list <- search()[
    ifelse(unlist(gregexpr("package:", search())) == 1, TRUE, FALSE)]

  package_list <- setdiff(package_list, basic_packages)

  if (length(package_list) > 0)  for (package in package_list) {
    detach(package, character.only = TRUE, unload = TRUE)
    print(paste("package ", package, " detached", sep = ""))
  }
}

detach_all_packages()

# this allows multiple persons to use the same RMarkdown
# without adjusting the working directory by themselves all the time
source("scripts/csf.R")
path_to_wd <- csf() # if this - for some reason - does not work,
# replace with a hardcoded path, like so: "~/projects/rddj-template/analysis/"
if ( is.null(path_to_wd) | !dir.exists(path_to_wd)) {
  print("WARNING: No working directory specified for current user")
} else {
  setwd(path_to_wd)
}

# suppress scientific notation
options(scipen = 999)

# unload global rstudioapi and knitr again to avoid conflicts with checkpoint
# this is only necessary if executed within RStudio
# outside of RStudio, namely in the knit.sh script, this causes RMarkdown
# rendering to fail, thus should not be executed there
if (Sys.getenv("RSTUDIO") == "1"){
  detach_all_packages()
}
```


### Packages definieren

```{r, echo=TRUE, message=FALSE, warning=FALSE}
# from https://mran.revolutionanalytics.com/web/packages/checkpoint/vignettes/using-checkpoint-with-knitr.html
# if you don't need a package, remove it from here (commenting is probably not sufficient)
# tidyverse: see https://blog.rstudio.org/2016/09/15/tidyverse-1-0-0/
cat("
library(rstudioapi)
library(tidyverse) # ggplot2, dplyr, tidyr, readr, purrr, tibble
library(lubridate) # date calculation
library(glue) # cooler string templating
library(magrittr) # pipes
library(readxl) # excel
library(scales) # scales for ggplot2
library(jsonlite) # json
library(lintr) # code linting
library(sf) # spatial data handling
library(rmarkdown)
# library(mailR)",
file = "manifest.R")
```

### Packages installieren

```{r, echo=TRUE, message=FALSE, warning=FALSE}
# if checkpoint is not yet installed, install it (for people using this
# system for the first time)
if (!require(checkpoint)) {
  if (!require(devtools)) {
    install.packages("devtools", repos = "http://cran.us.r-project.org")
    require(devtools)
  }
  devtools::install_github("RevolutionAnalytics/checkpoint",
                           ref = "v0.3.2", # could be adapted later,
                           # as of now (beginning of July 2017
                           # this is the current release on CRAN)
                           repos = "http://cran.us.r-project.org")
  require(checkpoint)
}
# nolint start
if (!dir.exists("~/.checkpoint")) {
  dir.create("~/.checkpoint")
}
# nolint end
# install packages for the specified CRAN snapshot date
checkpoint(snapshotDate = package_date,
           project = path_to_wd,
           verbose = T,
           scanForPackages = T,
           use.knitr = F,
           R.version = R_version)
rm(package_date)
```


### Packages laden

```{r, echo=TRUE, message=FALSE, warning=FALSE}
source("manifest.R")
unlink("manifest.R")
sessionInfo()
```

### Datenvorbereitung

```{r read data about councillors}

# list of municipality names to replace councillors cities in order to match BfS data
municpality_names <- c(
  "^Coira$" = "Chur",
  "^Birmenstorf$" = "Birmenstorf (AG)",
  "^Emmenbrücke$" = "Emmen",
  "^Geneve$" = "Genève",
  "^Azmoos$" = "Wartau",
  "^Avry-sur-Matran$" = "Avry",
  "^Rüegsauschachen$" = "Rüegsau",
  "^Carouge$" = "Carouge (GE)",
  "^Wil$" = "Wil (SG)",
  "^Gstaad$" = "Saanen",
  "^Nàfels$" = "Glarus Nord",
  "^Oberriet$" = "Oberriet (SG)",
  "^Kaltacker$" = "Heimiswil",
  "^Illnau$" = "Illnau-Effretikon",
  "^Edlibach$" = "Menzingen",
  "^Bürglen$" = "Lungern",
  "^Hergiswil$" = "Hergiswil (NW)",
  "^St-George$" = "Saint-George",
  "^Cheyres$" = "Cheyres-Châbles",
  "^Aesch$" = "Aesch (ZH)",
  "^Küssnacht$" = "Küssnacht (SZ)",
  "^Grand-Lancy$" = "Lancy",
  "^Rüi b\\. Büren$" = "Rüti bei Büren",
  "^Ruvigliana$" = "Lugano",
  "^Küsnacht$" = "Küsnacht (ZH)",
  "^Mälchi$" = "Fraubrunnen",
  "^Watt-Regensdorf$" = "Regensdorf",
  "^Gossau$" = "Gossau (ZH)",
  "^Rüthi \\(Rheintal\\)$" = "Rüthi (SG)",
  "^Auvernier$" = "Milvignes",
  "^Rapperswil$" = "Rapperswil-Jona",
  "^Morgins$" = "Troistorrents",
  "^Glion$" = "Montreux",
  "^Cinuos-chel$" = "S-chanf",
  "^Wohlen$" = "Wohlen (AG)",
  "^Affoltern am Ablis$" = "Affoltern am Albis",
  "^Wallenwil$" = "Eschlikon",
  "^Bironico$" = "Monteceneri",
  "^Oberflachs$" = "Schinznach",
  "^Nussbaumen$" = "Obersiggenthal",
  "^Opfertshofen$" = "Thayngen",
  "^Biel$" = "Biel/Bienne",
  "^Schwanden$" = "Glarus Süd",
  "^Haslen$" = "Glarus Süd",
  "^Le Sentier$" = "Le Chenit"
)

# read councillor data (246 councillors)
councillors_initial_data <- read_delim(
  "input/councillorsCouncillor-export_de_ergaenzt_mit_religion.csv",
  delim = ";"
  ) %>%
  # remove all c_ from column names to make further processing easier
  rename_at(
    vars(
      starts_with("c_")),
      ~ str_replace(., "^c_", "")
    ) %>%
  # convert birth date to date format
  mutate(birth_date = as.Date(birth_date, format = "%d.%m.%Y")) %>%
  # replace domicile names in order to match BfS names
  mutate(domicile_city_final = str_replace_all(
    domicile_city_final,
    municpality_names
  ))

# read data that was completed by email request
missing_data_completion <- read_csv(
  "input/Missing Data Parlamentarians - Sheet1.csv"
)

# exclude missing data from initial data set
councillors_no_missing <- councillors_initial_data %>%
  anti_join(missing_data_completion, by = "id")

# join completed data to original data set
councillors_missing_data_joined <- councillors_initial_data %>%
  select(
    -last_name,
    -birth_date,
    -gender,
    -religion,
    -education,
    -marital_status,
    -domicile_city_final
  ) %>%
  inner_join(missing_data_completion, by = "id")

# concat missing and non missing data
councillors <- councillors_no_missing %>%
  bind_rows(councillors_missing_data_joined)

```

#### Alter

```{r age groups}

# function to calculate age based on birth date
calc_age <- function(birth_date, ref_date = Sys.Date()) {
  period <- as.period(
    interval(birth_date, ref_date),
    unit = "year"
  )
  # return
  period$year
}

# function that puts people into 7 groups based on their age
get_group_for_age <- function(age) {
  case_when(
    age < 30 ~ "below 29",
    age < 40 ~ "30-39",
    age < 50 ~ "40-49",
    age < 60 ~ "50-59",
    age < 70 ~ "60-69",
    TRUE ~ "above 70"
  )
}

# create age groups for councillors
councillors_age <- councillors %>%
  # calculate age
  mutate(age = calc_age(birth_date)) %>%
  # use age_group for json export
  mutate(age_group = get_group_for_age(age)) %>%
  # reduce data
  select(age_group, id)

# age groups and percentage for councillors
age_groups_percentage_councillors <- councillors_age %>%
  group_by(age_group) %>%
  # count councillors, use id
  summarise(is = n_distinct(id)) %>%
  mutate(share = is / sum(is))

# read data for age of general population, data from end of 2017
general_population_age <- read_excel(
    "input/je-d-01.02.03.02.xlsx",
    sheet = "2017",
    skip = 5
  ) %>%
  rename(
    age = 1,
    total = 2,
    m = 3,
    f = 4,
    swiss = 5,
    foreigners = 6
  ) %>%
  # exclude footer rows
  filter(!is.na(total)) %>%
  # replace 105 und mehr  to 105 to only have numbers
  mutate(age = replace(age, age == "105 und mehr", 105)) %>%
  mutate(age = as.numeric(age)) %>%
  # select population older than 15 years
  filter(age >= 15) %>%
  # here use group instead of age_group for json export
  mutate(group = get_group_for_age(age))
  
# representation of age groups
age_groups_representation <- general_population_age %>%
  select(group, total) %>%
  group_by(group) %>%
  # sum up all values
  summarise(total = sum(total)) %>%
  # calculate share based on should values
  mutate(share = total / sum(total)) %>%
  mutate(should = round(share * 246, 0)) %>%
  # join councillors data (is values)
  left_join(
    age_groups_percentage_councillors %>%
      select(age_group, is),
    by = c("group" = "age_group")
  ) %>%
  mutate(category = "age_group") %>%
  select(category, group, is, should)
  
```

#### Geschlecht

```{r gender }

# percentage gender data councillors
gender_percentage_councillors <- councillors %>%
  group_by(gender) %>%
  # count councillors, use id
  summarise(is = n_distinct(id)) %>%
  mutate(share = is / sum(is))

# read gender data for general population
general_population_gender <- general_population_age %>%
  select(m, f) %>%
  summarise_all(sum) %>%
  gather(group, total)

# representation of gender
gender_representation <- general_population_gender %>%
  select(group, total) %>%
  group_by(group) %>%
  # sum up all values
  summarise(total = sum(total)) %>%
  # calculate share based on should values
  mutate(share = total / sum(total)) %>%
  mutate(should = round(share * 246, 0)) %>%
  # join councillors data (is values)
  left_join(
  gender_percentage_councillors %>%
    select(gender, is),
    by = c("group" = "gender")
  ) %>%
  mutate(category = "gender") %>%
  select(category, group, is, should)


```

#### Stadt / Land

```{r urban rural data}

# top 10 cities in Switzerland
big_10_names <- c(
  "Zürich",
  "Genève",
  "Bern",
  "Basel",
  "Lausanne",
  "Winterthur",
  "Luzern",
  "St. Gallen",
  "Lugano",
  "Biel/Bienne"
)

# read data for urban rural distinction
urban_rural <- read_excel(
  "input/Raumgliederungen.xlsx",
  sheet = "Daten",
  range = cell_cols("A:F")
) %>%
  filter(row_number() > 2) %>%
  rename(
    bfs_id = 1,
    municipality = 2,
    canton = 3,
    district_number = 4,
    district_name = 5,
    urban_rural = 6
  ) %>%
  mutate(
    urban_rural = case_when(
      urban_rural == 1 ~ "urban",
      urban_rural == 2 ~ "periurban",
      urban_rural == 3 ~ "rural",
      TRUE ~ urban_rural
    )
  ) %>%
  mutate(
    urban_rural = ifelse(
      municipality %in% big_10_names,
      "big_city",
      urban_rural
    )
  )

# read population data for every municipality, municpalities (2240 entries)
municipality_population <- read_excel(
  "input/su-d-01.02.03.06.xlsx",
  sheet = "2017",
  skip = 2
) %>%
  filter(row_number() > 3) %>%
  rename(
    geography = 1,
    total = 2
  )  %>%
  mutate(total = as.numeric(total)) %>%
  # exclude footer rows
  filter(!is.na(total)) %>%
  # exclude canton and district data
  filter(!str_detect(geography, "^-") & !str_detect(geography, "^>>")) %>%
  separate(geography, into = c("bfs_id", "municipality"), sep = 11) %>%
  mutate(bfs_id = str_extract(bfs_id, "\\d\\d\\d\\d")) %>%
  mutate(bfs_id = as.numeric(bfs_id)) %>%
  select(-total) %>%
  gather(age, population, -municipality, -bfs_id) %>%
  # replace 105 und mehr to 105 to only have numbers
  mutate(age = replace(age, age == "105 und mehr", 105)) %>%
  mutate(age = as.numeric(age)) %>%
  # select population older than 15 years
  filter(age >= 15) %>%
  group_by(municipality) %>%
  # sum up all ages to calcuate total population
  summarise(total = sum(population))

# join population data to urban rural distinction
general_population_urban_rural <- municipality_population %>%
  left_join(
    urban_rural %>%
      select(municipality, urban_rural),
    by = "municipality"
  ) %>%
  # here use group instead of urban_rural for json export
  rename(group = urban_rural)

# join councillors to urban rural data set
councillors_urban_rural <- councillors %>%
  mutate(
    domicile_city_final = str_replace(domicile_city_final, "\\s\\d*$", "")
  ) %>%
  left_join(
    urban_rural %>%
      select(municipality, urban_rural),
    by = c("domicile_city_final" = "municipality")
  ) %>%
  # reduce data
  select(urban_rural, id)

# calculate percentage of urban rural councillors
councillors_urban_rural_percentage <- councillors_urban_rural %>%
  group_by(urban_rural) %>%
  # count councillors, use id
  summarise(is = n_distinct(id)) %>%
  mutate(share = is / sum(is))

# representation of urban rural population
urban_rural_representation <- general_population_urban_rural %>%
  select(group, total) %>%
  group_by(group) %>%
  # sum up all values
  summarise(total = sum(total)) %>%
  # calculate share based on should values
  mutate(share = total / sum(total)) %>%
  mutate(should = round(share * 246, 0)) %>%
  # join councillors data (is values)
  left_join(
    councillors_urban_rural_percentage %>%
      select(urban_rural, is),
    by = c("group" = "urban_rural")
  ) %>%
  mutate(category = "urban_rural") %>%
  select(category, group, is, should)

```

#### Bildung

```{r read education data}

#education renaming to match BfS categories
# nolint start
educatoion_renaming <- c(
  "^Handelsschule oder Handelsdiplom$" = "secondary_profession",
  "^Berufslehre oder Berufsschule$" = "secondary_profession",
  "^Diplommittellschule oder allgemeinbildende Schuke$" = "secondary_general_education",
  "^Diplommittellschule oder allgemeinbildende Schule$" = "secondary_general_education",
  "^Maturitätsschule, Gymnasium oder Seminar$" = "secondary_general_education",
  "^Höhere Berufsausbildung \\(Meisterdiplom, höhere Fachausweise etc\\.\\)$" = "tertiary_higher_profession",
  "^Höhere Berufsausbildung*$" = "tertiary_higher_profession",
  "^Höhere Fachschule$" = "tertiary_higher_profession",
  "^Höhere Berufsausbildung$" = "tertiary_higher_profession",
  "^Höhere Fachschule \\(Krankenpflegeschule, Schule für Sozialarbeit etc\\.\\)$" = "tertiary_higher_profession",
  "^Fachhochsule oder Technikum$" = "tertiary_university",
  "^Fachhochschule oder Technikum$" = "tertiary_university",
  "^Universität oder ETH$" = "tertiary_university",
  "^Anderer Bildungsabschluss$" = "unknown",
  "\\?" = "unknown"
)

# education renaming for short English version
educatoion_renaming_short <- c(
  "^Handelsschule oder Handelsdiplom$" = "secondary",
  "^Berufslehre oder Berufsschule$" = "secondary",
  "^Diplommittellschule oder allgemeinbildende Schuke$" = "secondary",
  "^Diplommittellschule oder allgemeinbildende Schule$" = "secondary",
  "^Maturitätsschule, Gymnasium oder Seminar$" = "secondary",
  "^Höhere Berufsausbildung \\(Meisterdiplom, höhere Fachausweise etc\\.\\)$" = "tertiary",
  "^Höhere Berufsausbildung*$" = "tertiary",
  "^Höhere Fachschule$" = "tertiary",
  "^Höhere Berufsausbildung$" = "tertiary",
  "^Höhere Fachschule \\(Krankenpflegeschule, Schule für Sozialarbeit etc\\.\\)$" = "tertiary",
  "^Fachhochsule oder Technikum$" = "tertiary",
  "^Fachhochschule oder Technikum$" = "tertiary",
  "^Universität oder ETH$" = "tertiary",
  "^Anderer Bildungsabschluss$" = "unknown",
  "\\?" = "unknown",
  "keine Angabe" = "unknown"
)

# nolint end

councillors_education <- councillors %>%
  mutate(
    education = str_replace_all(
      education,
      educatoion_renaming_short
      )
    ) %>%
  # reduce data
  select(education, id)

# calculate count of education type by councillors
councillors_education_percentage <- councillors_education %>%
  group_by(education) %>%
  # count councillors, use id
  summarise(is = n_distinct(id)) %>%
  # add share
  mutate(share = is / sum(is))

#read data for 2017, general population from age 15 on
education_general_population <- read_excel(
  "input/su-d-40.02.15.08.01-2017.xlsx",
  sheet = "Schweiz",
  skip = 3
  ) %>%
  filter(row_number() < 2) %>%
  rename(
    obligatory = 5,
    secondary_profession = 7,
    secondary_general_education = 9,
    tertiary_higher_profession = 11,
    tertiary_university = 13
  ) %>%
  mutate(
    secondary =
      as.numeric(secondary_profession) +
      as.numeric(secondary_general_education)
    ) %>%
  mutate(
    tertiary =
      as.numeric(tertiary_higher_profession) +
      as.numeric(tertiary_higher_profession)
    ) %>%
  # make data tidy to have key and total value on one line
  select(
    obligatory,
    secondary,
    tertiary
  ) %>%
  gather(
    group,
    total
  ) %>%
  mutate(total = as.numeric(total))

# representation of education
education_representation <- education_general_population %>%
  select(group, total) %>%
  group_by(group) %>%
  # calculate total, needed for share calculation
  summarise(total = sum(total)) %>%
  mutate(share = total / sum(total)) %>%
  # calculate councillors that should be in parliament
  mutate(should = round(share * 246, 0)) %>%
  # join councillors data (is values)
  full_join(
    councillors_education_percentage %>%
      select(education, is),
    by = c("group" = "education")
  ) %>%
  # add category for export
  mutate(category = "education") %>%
  select(category, group, is, should) %>%
  mutate(is = ifelse(is.na(is), 0, is))

```


#### Familienstatus

```{r marital status}

# define groups to extract data from BfS file
marital_status_filter <- c(
  "Ledig",
  "Verheiratet",
  "Geschieden",
  "In eingetragener Partnerschaft",
  "Verwitwet",
  "Unverheiratet",
  "Aufgelöste Partnerschaft"
)

general_population_marital_status <- read_excel(
  "input/su-d-01.02.03.03.xlsx",
  sheet = "2017",
  skip = 3
) %>%
  rename(
    group = 1,
    total = 2
  ) %>%
  select(group, total) %>%
  filter(group %in% marital_status_filter) %>%
  # subtract amout of people younger than 15 years (1269033)
  mutate(total = ifelse(group == "Ledig", total - 1269033, total))
  
# rename councillors data to match BfS categories
marital_status_renaming <- c(
  "^geschieden$" = "Geschieden",
  "^getrennt$" = "Geschieden",
  "^in eingetragener Partnerschaft$" = "In eingetragener Partnerschaft",
  "^ledig$" = "Ledig",
  "^leidig$" = "Ledig",
  "^verheiratet$" = "Verheiratet",
  "^verwitwet$" = "Verwitwet"
)

councillors_marital_status <- councillors %>%
  mutate(
    marital_status = str_replace_all(
      marital_status,
      marital_status_renaming
      )
    ) %>%
  # reduce data
  select(marital_status, id)

# calculate percentage of marital status councillors
councillors_marital_status_percentage <- councillors_marital_status %>%
  group_by(marital_status) %>%
  # count councillors, use id
  summarise(is = n_distinct(id)) %>%
  mutate(share = is / sum(is))

# rename variables for export
marital_status_export_renaming <- c(
  "Verheiratet" = "married",
  "In eingetragener Partnerschaft" = "partnership",
  "Ledig" = "single",
  "\\?" = "unknown",
  "Geschieden" = "divorced",
  "Verwitwet" = "widowed",
  "keine Angabe" = "unknown"
)

# representation of marital status
marital_status_representation <- general_population_marital_status %>%
  select(group, total) %>%
  group_by(group) %>%
  # calculate total, needed for share calculation
  summarise(total = sum(total)) %>%
  mutate(share = total / sum(total)) %>%
  # calculate councillors that should be in parliament
  mutate(should = round(share * 246, 0)) %>%
  # join councillors data (is values)
  full_join(
    councillors_marital_status_percentage %>%
      select(marital_status, is),
    by = c("group" = "marital_status")
  ) %>%
  # add category for export
  mutate(category = "marital_status") %>%
  select(category, group, is, should) %>%
  filter(!is.na(is)) %>%
  # replace by English variable names
  mutate(group = str_replace_all(
    group,
    marital_status_export_renaming
  ))

```

#### Religion

```{r religion data}

religion_renaming <- c(
  "^Andere christliche Gemeinschaften$" = "other_religion",
  "^andere christliche Gemeinschaften$" = "other_religion",
  "^Christ-katholisch$" = "catholic",
  "^keine Angabe$" = "unknown",
  "\\?" = "unknown",
  "^Islamische Gemeinschaften$" = "muslim",
  "^Protestantisch$" = "protestant",
  "^Römisch-katholisch$" = "catholic",
  "^Konfessionslos$" = "undenominational"
)

religion_export_renaming <- c(
  "^jewish$" = "other_religion",
  "^other_christian$" = "other_religion"
)

general_population_religion <- read_excel(
  "input/je-d-01.08.02.01.xlsx",
  sheet = "1910-2017",
  range = "A22:R22",
  col_names = FALSE
) %>%
  select(
    protestant = 3,
    catholic = 5,
    other_christian = 7,
    jewish = 9,
    muslim = 11,
    other_religion = 13,
    undenominational = 15
  ) %>%
  gather(group, share) %>%
  # mark jewish and other_christian as other religion
  mutate(group = str_replace_all(
    group,
    religion_export_renaming
  )) %>%
  # group by religion type
  group_by(group) %>%
  # sum up all religions
  summarise(share = sum(share)) %>%
  # make share a decimal value
  mutate(share = share / 100)

councillors_religion <- councillors %>%
  mutate(
    religion = str_replace_all(
      religion,
      religion_renaming
    )
  ) %>%
  # reduce data
  select(religion, id)

# calculate percentage of religion, councillors
councillors_religion_percentage <- councillors_religion %>%
  group_by(religion) %>%
  # count councillors, use id
  summarise(is = n_distinct(id)) %>%
  mutate(share = is / sum(is))

# representation of religion
religion_representation <- general_population_religion %>%
  select(group, share) %>%
  # calculate councillors that should be in parliament
  mutate(should = round(share * 246, 0)) %>%
  # join councillors data (is values)
  full_join(
    councillors_religion_percentage %>%
      select(religion, is),
    by = c("group" = "religion")
  ) %>%
  # add category for export
  mutate(category = "religion") %>%
  select(category, group, is, should) %>%
  # set na values of is to 0
  mutate(is = ifelse(is.na(is), 0, is))

```


### Charts

```{r create charts}

save_barchart <- function(data, title) {
  ggplot(
    data = data %>%
      mutate(missing = is - should),
    aes(
      x = group,
      y = missing,
      label = missing,
      fill = category
    )
  ) +
    geom_bar(stat = "identity") +
    geom_text(
      position = position_stack(vjust = 0.5),
      color = "white",
      size = 3
    ) +
    scale_fill_brewer(palette = "Set1") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(
      title = title,
      y = "Abweichung",
      x = ""
    )

  ggsave(glue::glue("output/ignore/{title}.png"))
}

save_barchart_with_factors <- function(data, title, factors) {
  ggplot(
    data = data %>%
      mutate(missing = is - should) %>%
      mutate(group = factor(group, levels = factors)),
    aes(
      x = group,
      y = missing,
      label = missing,
      fill = category
    )
  ) +
    geom_bar(stat = "identity") +
    geom_text(
      position = position_stack(vjust = 0.5),
      color = "white",
      size = 3
    ) +
    scale_fill_brewer(palette = "Set1") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(
      title = title,
      y = "Abweichung",
      x = ""
    )

  ggsave(glue::glue("output/ignore/{title}.png"))
}

save_barchart(gender_representation, "Repräsentation Geschlecht")

save_barchart(education_representation, "Repräsentation Bildung")

save_barchart(urban_rural_representation, "Repräsentation Stadt Land")

save_barchart(marital_status_representation, "Repräsentation Zivilstand")

save_barchart(religion_representation, "Repräsentation Religion")

save_barchart_with_factors(
  age_groups_representation,
  "Repräsentation Alter",
  c(
    "below 29",
    "30-39",
    "40-49",
    "50-59",
    "60-69",
    "above 70"
  )
)

```
 
### Export

```{r export data}

councillors_export <- councillors %>%
   select (
    id,
    first_name,
    last_name,
    gender,
    party,
    canton
  ) %>%
  left_join(councillors_age, by = "id") %>%
  left_join(councillors_urban_rural, by = "id") %>%
  left_join(councillors_marital_status, by = "id") %>%
  left_join(councillors_education, by = "id") %>%
  left_join(councillors_religion, by = "id") %>%
  select (
    id,
    first_name,
    last_name,
    age_group,
    gender,
    urban_rural,
    marital_status,
    education,
    religion,
    party,
    canton
  ) %>%
  mutate(marital_status = str_replace_all(
    marital_status,
    marital_status_export_renaming
  ))

# unfortunately R and Javascript work with different variable naming systems
# in R snake_case is predominant, in Javascript it's camelCase, so we'll have
# to convert the column names in the export to match the javascript world
convert_column_names_to_camel_case <- function(df) {
  df %>%
    rename_at(
      vars(matches("_[a-z]")),
      # unfortunately the stringr package does not offer a possibility
      # to convert to uppercase in replace, so we use sub
      ~ sub("_([a-z])", "\\U\\1", ., perl = TRUE)
    )
}

write_csv(councillors_export, "output/councillors_supplemented.csv")

representation_export <- bind_rows(
  age_groups_representation,
  gender_representation,
  urban_rural_representation,
  marital_status_representation,
  education_representation,
  religion_representation
)

write_csv(representation_export, "output/representation.csv")

```

## Linting

Der Code in diesem RMarkdown wird mit [lintr](https://github.com/jimhester/lintr) automatisch auf den Wickham'schen [tidyverse style guide](http://style.tidyverse.org/) überprüft.  

```{r echo=TRUE, message=FALSE, warning=FALSE}
lintr::lint(
  "main.Rmd",
  linters = lintr::with_defaults(
    object_length_linter(45)
  )
)
```
